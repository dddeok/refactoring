## 7. 캡슐화

**모듈을 분리하는 가장 중요한 기준은 자신을 제외한 다른 부분에 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있을것이다.**

**대표적인 데이터 구조**

1. 레코드 캡슐화 하기
2. 컬렉션 캡슐화 하기
3. 기본현을 객체로 바꾸기
4. 임시 변수를 질의 함수로 바꾸기

**클래스는 본래 정보를 숨기는 용도로 설계 되었다.**

1. 여러 함수를 클래스로 묶기
2. 클래스 추출하기
3. 클래스 인라인하기
4. 위임 숨기기
5. 중개자 제거하기

**함수 캡슐화**

1. 함수 추출하기
2. 알고리즘 교체하기

### 7.1 레코드 캡슐화하기

- 대부분의 프로그래밍 언어는 데이터 레코드를 표현하는 구조를 제공한다.
- 저자는 가변 데이터를 저장하는 용도로는 레코드보다 객체를 선호한다.

**레코드 구조**

1. 필드 이름을 노출하는 형태
2. (필드를 외부로부터 숨겨서) 내가 원하는 이름을 쓸 수 있는 형태.

**예시에 따르면, 입력 데이터 레코드와의 연결을 끊어준다는 이점이 생긴다고 한다...**

이 레코드를 참조하여 캡슐화를 깰 우려가 있는 코드가 많을 때 좋다.

- 데이터를 개별 필드로 펼치지 않았다면, \_data를 대입할 때 복제하는 식으로 처리 했을 것이다.

**중첩된 레코드 구조**

- 읽는 패턴이 다양하면 그만큼 작성할 코드가 늘어날 수 있다.
- 리스트-해시(list-and-hash) 데이터 구조를 쉽게 다룰 수 있음
- 클라이언트가 데이터 구조를 요청할 때 실제 데이터를 제공해도 된다.
  - 하지만 데이터를 수정하지 못하게 막을 방법이 없다. (캡슐화의 원칙을 깰 수 있음)
  - 내부 데이터를 복제해서 제공하는 것
- 데이터 구조가 클수록 복제 비용이 커져서 성능이 느려질 수 있다.

**클라이언트가 원본을 수정한다고 착각 할 수 있다.**

- 읽기전용 프락시 제공 혹은 복제본을 동결시켜 데이터 수정하려 할 때 에러를 던짐.
- 레코드 캡슐화를 재귀적으로 하는 것??
  - 정적인 정보 레코드를 클래스로 바꾸고, 컬렉션 캡슐화하기로 레코드를 다루는 코드를 리팩터링 함으로써 정적 정보를 다루는 클래스를 생선한다.
  - 하지만, 데이터 구조가 거대하면 일이 상당히 커진다.

### 7.2 컬렉션 캡슐화하기

**가변 데이터를 캡슐화 하게 되면, 데이터 구조가 언제 어떻게 수정되는지 파악하기 쉬워서 필요한 시점에 데이터 구조를 변경하기도 쉬어진다.**

- 컬렉션을 소유한 클래스를 통해서만, 원소를 변경하도록하면 프로그램을 개선하면서 컬렉션 변경 방식도 원하는대로 수정할 수 있다.
- 컬렉션 게터가 원본 컬렉션을 반환하지 않게 만들어서 클라이언트가 실수로 컬렉션을 바꿀 가능성을 차단하는게 낫다.
- 가장 흔히 사용하는 방식으로는 아마도 컬렉션 게터를 제공하되 내부 컬렉션의 복제본을 반환하는 것이다.
- 여기서도, 컬렉션이 상당히 크다면 성능문제가 발생할 수 있으나 (성능에대한 이슈는 일반 규칙을 따르도록 하자)
- 코드베이스에서 일관성을 유지
- 불필요한 복제본을 만드는 편이, 예상치 못한 수정이 촉발한 오류를 디버깅하는 것 보다 낫다.

### 7.3 기본형을 객체로 바꾸기

**단순한 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스를 정의 해야한다 (Value Class).**

- 직관에 어긋나 보일 수 있다.
- 리팩터링 중에서도 가장 유용한 것으로 손꼽는다.

### 7.4 임시 변수를 질의 함수로 바꾸기

**임시 변수를 사용하면 값을 계산하는 코드가 반복되는걸 줄이고 값의 의미를 설명할 수 있어 유용하다.**

- 긴 함수의 한 부분을 별도 함수로 추출하고자 할 때 먼저 변수들을 각각의 함수로 만들면 일이 수월해진다.
- 추출한 함수에 변수를 따로 전달할 필요가 없어지기 때문이다.
- 클래스 안에서 적용할 때 효과가 가장 크다.
  - 변수는 값을 한 번만 계산하고, 그 뒤로는 읽기만 해야한다 (상수 처리도 하나의 방법)

### 7.5 클래스 추출하기

**클래스는 반드시 명확하게 추상화하고 소수의 주어진 역할만 처리해야 한다.**

- 새로운 역할을 덧씌우기 쉬운데, 역할이 많아질 수록 클래스가 복잡해진다.
- 메서드와 데이터가 너무 많은 클래스는 이해하기 쉽지 않으니 잘 살펴보고 적절히 분리해야 한다.
- 일부 데이터와 메서드를 따로 묶을 수 있다면 어서 분리하라는 신호이다.

### 7.6 클래스 인라인하기

**클래스 추출하기를 거꾸로 돌리는 리팩터링, 이는 코드를 재구성할 때 흔히 사용하는 방식이기도 하다.**

- 특정 클래스에 남은 혁알이 거의 없을때
- 가장 많이 사용하는 클래스로 흡수 시켜라

### 7.7, 7.8 위임 숨기기 vs 중개자 제거하기

**모듈화 설계를 제대로 하는 핵심은 캡슐화 이다. 캡슐화가 잘되어 있따면 무언가를 변경해야 할 때 함께 고려해야 할 모듈 수가 적어져서 코드를 변경하기 쉬워진다.**

- 자주 쓰는 위임은 그대로 두는편이 클라이언트 입장에서 편하다.
- 둘 중 하나를 반드시 해야 한다는 법은 없다. 상황에 맞게 처리하라

### 7.9 알고리즘 교체하기.

- 리팩터링을 하면 복잡한 대상을 단순한 단위로 나눌 수 있지만, 때로는 알고리즘 전체를 걷어내고 훨씬 간결한 알고리즘으로 바꿔야 할 때가 있다.
- 문제를 더 확실히 이해하고 훨씬 쉽게 해결하는 방법을 발견했을 때 이러한 방식을 취한다. (같은 기능을 하는 라이브러리를 발견했을 때도 포함)
- 메서드가 가능한 잘게 나눴는지 확인이 필요하다.
- 알고리즘을 간소화 하는 작업 부터해야 교체가 쉬워진다.

[[번역] 심층 분석: React Hook은 실제로 어떻게 동작할까?](https://hewonjeong.github.io/deep-dive-how-do-react-hooks-really-work-ko/)
